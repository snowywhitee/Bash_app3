# ITMO OS 3 sem M3

<!-- TABLE OF CONTENTS -->
<details open="open">
  <summary>Table of Contents</summary>
  <ol>
    <li><a href="#questions">Questions</a></li>
    <li>
      <a href="#theory">Theory</a>
      <ul>
        <li><a href="#commands-union">Commands Union</a></li>
        <li><a href="#commands-managing">Commands Managing</a></li>
        <li><a href="#process-interactions">Process Interactions</a></li>
      </ul>
    </li>
    <li><a href="#task">Task</a></li>
    <li><a href="#description">Description</a></li>
  </ol>
</details>

## Questions

1. Директивы объединения команд
2. Команды для управления процессами
3. Планирование времени запуска процессов
4. Организация межпроцессного взаимодействия

## Theory

### Commands Union

**команда1 | команда2** – перенаправление стандартного вывода,

**команда1 ; команда2** – последовательное выполнение команд,

**команда1 && команда2** – выполнение команды при успешном завершении предыдущей,

**команда1 || команда2** – выполнение команды при неудачном завершении предыдущей,

**команда1 $(команда2)** – передача результатов работы команды 2 в качестве аргументов запуска команды 1,

**команда 1 > файл** – направление стандартного вывода в файл (содержимое существующего файла удаляется),

**команда 1 >> файл** – направление стандартного вывода в файл (поток дописывается в конец файла).
**{**
**команда1**
**команда2**
**} – объединение команд после директив || , && или в теле циклов и функций.

**команда1 &** – запуск команды в фоновом режиме (стандартный вход и стандартный выход не связаны с
консолью, из которой запускается процесс; управление процессом возможно в общем случае только с помощью
сигналов).

### Commands Managing

**kill** – передает сигнал процессу. Сигнал может передаваться в виде его номера или символьного обозначения.
По умолчанию (без указания сигнала) передает сигнал требования о завершении процесса завершения процесса
(TERM). Идентификация процесса для команды kill производится по PID. Перечень системных сигналов,
доступных в GNU/Linux, с указанием их номеров и символьных обозначений можно получить с помощью
команды kill –l;

**killall** – работает аналогично команде kill, но для идентификации процесса использует его символьное имя, а
не PID;

**pidof** – определяет PID процесса по его имени;

**pgrep** – определяет PID процессов с заданными характеристиками (например, запущенные конкретным
пользователем);

**pkill** – позволяет отправить сигнал группе процессов с заданными характеристиками;

**nice** – запускает процесс с заданным значением приоритета. Уменьшение значения (повышение приоритета
выполнения) может быть инициировано только пользователем root;

**renice** – изменяет значения приоритета для запущенного процесса. Уменьшение значения (повышение
приоритета выполнения) может быть инициировано только пользователем root;

**at** – осуществляет однократный отсроченный запуск команды.

**cron** – демон, который занимается планированием и выполнением команд, запускаемых по определенным датам
и в определенное время. Команды, выполняемые периодически, указываются с использованием команды
crontab. Команды, которые должны быть запущены лишь однажды, добавляются при помощи at. Синтаксис
строки в crontab подробно описан здесь: http://www.opennet.ru/man.shtml?topic=crontab&category=5&russian=2.

**tail** – не только выводит последние n строк из файла, но и позволяет организовать "слежение" за файлом –
обнаруживать и выводить новые строки, появляющиеся в конце файла.

**sleep** – задает паузу в выполнении скрипта.

### Process Interactions

Именованный канал – специальный тип файла в Linux. Создается командой **mkfifo** имя_файла.
Взаимодействие с именованным каналом происходит обычными средствами для взаимодействия с файлами, но

при этом такой файл не будет сохраняться на носителе, а представляет собой буфер в памяти для организации
межпроцессного обмена данными.
Для демонстрации передачи информации через именованный канал рассмотрим два скрипта – «Генератор» и
«Обработчик». Требуется считывать информацию с одной консоли с помощью процесса «Генератор» и выводить
ее на экран другой консоли с помощью процесса «Обработчик», причем таким образом, чтобы считывание
генератором строки «QUIT» приводило к завершению работы обработчика. Каждый скрипт запускается
независимо в своей виртуальной консоли. Переключаясь между консолями, можно управлять скриптами и
наблюдать результаты их работы.

Для замены обработчиков сигналов в sh (bash) используется встроенная команда trap с форматом **trap action signal**
Команде нужно передать два параметра: действие при получении сигнала и сигнал, для которого будет
выполняться указанное действие. Обычно в качестве действия указывают вызов функции, описанной выше в коде
скрипта. С помощью команды **trap** можно не только задать обработчик для пользовательского сигнала, но и подменить
обработчик для некоторых из системных сигналов (кроме тех, перехват которых запрещен). В этом случае
обработка сигнала перейдет к указанному в trap обработчику.

## Task

Создайте скрипты или запишите последовательности выполнения команд для перечисленных заданий и
предъявите их преподавателю.

1. Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и
операторы проверки свойств и значений), который будет пытаться создать директорию test в
домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл ~/report
сообщение вида "catalog test was created successfully" и создаст в директории test
файл с именем Дата_Время_Запуска_Скрипта. Затем независимо от результатов предыдущего шага
скрипт должен опросить с помощью команды ping хост www.net_nikogo.ru и, если этот хост
недоступен, дописать сообщение об ошибке в файл ~/report. Сообщение об ошибке должно
начинаться с текущей Дата_Время, а затем содержать через пробел произвольный текст сообщения об
ошибке.

2. Задайте еще один однократный запуск скрипта из пункта 1 через 2 минуты. Консоль после этого должна
оставаться свободной. Выполнив отдельную команду организуйте слежение за файлом ~/report и
выведите на консоль новые строки из этого файла, как только они появятся.

3. Задайте запуск скрипта из пункта 1 в каждую пятую минут каждого часа в день недели, в который вы
будете выполнять работу.

4. Создайте три фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например,
перемножение двух чисел). После запуска процессов должна сохраниться возможность использовать
виртуальную консоль, с которой их запустили. Используя команду top, проанализируйте процент
использования ресурсов процессора этими процессами. Создайте скрипт, который будет в
автоматическом режиме обеспечивать, чтобы тот процесс, который был запущен первым, использовал
ресурс процессора не более чем на 10%. Послав сигнал, завершите работу процесса, запущенного
третьим. Проверьте, что созданный скрипт по-прежнему удерживает потребление ресурсов процессора
первым процессом в заданном диапазоне.

5. Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» передает информацию процессу
«Обработчик» с помощью именованного канала. Процесс «Обработчик» должен осуществлять
следующую обработку переданных строк: если строка содержит единственный символ «+», то процесс
обработчик переключает режим на «сложение» и ждет ввода численных данных. Если строка содержит
единственный символ «*», то обработчик переключает режим на «умножение» и ждет ввода численных
данных. Если строка содержит целое число, то обработчик осуществляет текущую активную операцию
(выбранный режим) над текущим значением вычисляемой переменной и считанным значением
(например, складывает или перемножает результат предыдущего вычисления со считанным числом). При
запуске скрипта режим устанавливается в «сложение», а вычисляемая переменная приравнивается к 1. В
случае получения строки **QUIT** скрипт «Обработчик» выдает сообщение о плановой остановке и оба
скрипта завершают работу. В случае получения любых других значений строки оба скрипта завершают
работу с сообщением об ошибке входных данных.

6. Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» считывает с консоли строки в
бесконечном цикле. Если считанная строка содержит единственный символ «+», он посылает процессу
«Обработчик» сигнал **USR1**. Если строка содержит единственный символ «*», генератор посылает
обработчику сигнал **USR2**. Если строка содержит слово **TERM**, генератор посылает обработчику сигнал
**SIGTERM** и завершает свою работу. Другие значения входных строк игнорируются. Обработчик
добавляет 2 или умножает на 2 текущее значение обрабатываемого числа (начальное значение принять на
единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран.
Вычисление и вывод производятся один раз в секунду. Получив сигнал **SIGTERM**, «Обработчик»
завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.

## Description
